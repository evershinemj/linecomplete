	     *j = move[0] - 'b';
 for (y = miny; y <= maxy; y++)
   for (x = minx; x <= maxx; x++)
     if (p[y][x] != EMPTY) return 0;
	  *j = move[0] - 'a';
	  count(i - 1, j, color);
	  if ((move[0] >= 'j') && (move[0] <= 't'))
               int *j,    /* column number of next move */
               int *val)  /* value of next move */
       *j = move[0] - 'B';
       if ((move[0] >= 'a') && (move[0] <= 'h'))
       if ((p[i - 1][j] == color) && ml[i - 1][j])
       ml[i - 1][j] = EMPTY;
    *j = move[0] - 'A';
    if ((move[0] >= 'J') && (move[0] <= 'T'))
    if ((p[i - 1][j] == EMPTY) && ml[i - 1][j])
 *i = 19 - k;
 if ((*i >= 0) && (*i <= 18))
 if ((move[0] >= 'A') && (move[0] <= 'H'))
 if (move[2]) k = k * 10 + move[2] - '0';
 k = move[1] - '0';
extern unsigned char l[19][19];   /* liberty of current color */
extern unsigned char ml[19][19];  /* working matrix for marking */
extern unsigned char p[19][19];   /* go board */
int findwinner(int *i,    /* row number of next move */
